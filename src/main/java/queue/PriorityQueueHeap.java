package queue;

/**
 * Приоритетная очередь на базе пирамиды(кучи)
 * Пирамидой называется двоичное дерево, обладающее следующими характеристиками:
 * 1) Полнота. Все уровни дерева содержат все возможные узлы(хотя последний уровень
 * может быть заполнен лишь частично)
 * 2) Для каждого узла в пирамиде выполняется основное условие, гласящее, что ключ
 * каждого узла меньше(либо равен) ключей его потомков.
 *
 * Пирамида обычно реализуется на базе массива. Из того факта, что пирамида является
 * полным двоичным деревом, следует, что в массиве, который используется для ее представления,
 * нет "дыр". Заполнены все ячейки от 0 до size-1.
 *
 * Мы будем писать пирамиду, где на вершине находится минимальный элемент.
 * Но можно реализовать и пирамиду, где на вершине максимальный элемент, и каждый узел больше(или равен)
 * своих потоков.
 *
 * По сравнению с деревом двоичного поиска, в котором ключ левого потомка каждого узла меньше ключа правого потомка,
 * пирамида является слабо упорядоченной.
 */

public class PriorityQueueHeap<T> implements PriorityQueue<T> {

    private Object[] heap = new Object[4];
    private int size;

    /**
     * Сначала проверяем, осталось ли в массиве свободное место. Новый элемент
     * всегда вставляется в первую свободную ячейку массива, справа от
     * последнего узла на нижнем уровне пирамиды. После этого этот элемент
     * перемещается в правильную позицию.
     *
     * Алгоритм смещения вверх проще алгоритма смещения вниз, потому что он не требует сравнения двух
     * потомков. Узел имеет только одного родителя, так что вставляемый узел
     * просто меняется местами с родителем, пока не дойдет большего предка или
     * не станет корневым узлом.
     * Можно сократить количество перестановок, если действовать способом аналогичным тому,
     * который применяется в сортировке вставками: запоминаем значение узла, смещаем его родителей вниз
     * посредством копирования на каждом шаге значения родителя в текущую ячейку. А после того как дошли
     * до нужной позиции узла, записываем его значение в ячейку один раз.
     */
    @SuppressWarnings("unchecked")
    @Override
    public void offer(T e) {
        if (e == null) {
            throw new NullPointerException();
        }
        ensureCapacity(size + 1);
        if (size == 0) {
            heap[0] = e;
        } else {
            upHeapify(size, e);
        }
        size++;
    }

    private void upHeapify(int k, T x) {
        Comparable<? super T> key = (Comparable<? super T>) x;
        while (k > 0) {
            int parent = (k - 1) >>> 1;
            Object e = heap[parent];
            if (key.compareTo((T) e) >= 0) {
                break;
            }
            heap[k] = e;
            k = parent;
        }
        heap[k] = key;
    }


    private void ensureCapacity(int size) {
        if (size <= heap.length) {
            return;
        }
		/*
		 * создаем новый массив размера в 2 раза больше, чем количество
		 * элементов, которое мы хотим там разместить
		 */
        Object[] newElements = new Object[2 * size];
        // копируем в него элементы из старого массива
        for (int i = 0; i < heap.length; i++) {
            newElements[i] = heap[i];
        }
        // присваеваем новый массив полю elements
        heap = newElements;
    }

    /**
     * Минимальный узел всегда является корневым и хранится в нулевой ячейке массива.
     * Проблема в том, что после удаления корень необходимо заполнить.
     * Вместо сдвига всех элементов на одну позицию вперед используется более быстрое решение:
     * 1) Удалить корневой узел
     * 2) Переместить последний узел на место корневого
     * 3) Смещать его вниз до тех пор, пока он не окажется ниже меньшего и выше большего узла.
     */
    @SuppressWarnings("unchecked")
    @Override
    public T poll() {
        if (size == 0) {
            return null;
        }
        --size;
        //запоминаем значение корневого узла
        T result = (T)heap[0];
        //перемещаем последний узел на место корневого
        heap[0] =  heap[size];
        //удаляем лишнюю ссылку, которая осталась от последнего элемента
        heap[size] = null;
        if (size != 0) {
            //смещаем новую вершину вниз до позиции удовлетворяющей свойству пирамиды
            downHeapify(0);
        }
        return result;
    }

    /**
     * Смещает узел с индексом index вниз до тех пор, пока он не окажется ниже меньшего и выше большего узла.
     * @param index индекс смещаемого вниз узла
     */
    @SuppressWarnings("unchecked")
    private void downHeapify(int index) {
        Comparable<? super T> key = (Comparable<? super T>) heap[index];
        int half = size / 2;
        //пока у узла имеется хотя бы один потомок
        while (index < half) {
            int leftChild = 2*index + 1;
            int rightChild = leftChild + 1;
            //определяем индекс большего потомка
            int smallestChild = leftChild;
            //если правый потомок существует и он больше левого
            if (rightChild < size && ((Comparable<? super T>) heap[leftChild]).compareTo((T) heap[rightChild]) > 0) {
                smallestChild = rightChild;
            }
            //если текущей узел меньше обоих потомков, то смещение вниз закончено
            if (key.compareTo((T) heap[smallestChild]) <= 0) {
                break;
            }
            //в противном случае меньший потомок перемещается на место текущего узла
            heap[index] = heap[smallestChild];
            //перемещаем индекс на место меньшего потомка и продолжем смещение вниз тем же алготитмом
            index = smallestChild;
        }
        //вставляем узел в нужную позицию
        heap[index] = key;
    }

    @SuppressWarnings("unchecked")
    @Override
    public T peek() {
        return (T) heap[0];
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return false;
    }

    @Override
    public void printQueue() {
        for (int i = 0; i < size; i++) {
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }

}
