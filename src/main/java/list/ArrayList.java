package list;

/**
 * Список на основе массива
 *
 * Ключевое слово extends, а затем имя родительского класса указывает на то, что данный класс расширяет другой класс,
 * наследуется от другого класса. В данном случае класс ArrayList расширяет класс AbstractList.
 * Класс AbstractList - родительский класс класса ArrayList.
 * Класс ArrayList производный от класса AbstractList.
 *
 * Класс ArrayList наследует все public и protected поля и методы родительского класса.
 * Обратите внимание, что внутри класса мы обращаемся к полю size, хотя оно здесь не объявлено.
 * Поле size унаследовалось от родительского класса.
 *
 * Благодаря наследованию объект типа ArrayList также является объектом типа AbstractList.
 * Следующая запись абсолютно корректна AbstractList list = new ArrayList();
 *
 */
public class ArrayList extends AbstractList {
    /**
     * Массив, в котором хранятся значения элементов списка
     *
     * elements - это поле класса ArrayList.
     *
     * Модификатор доступа у данного поля - private. Это означает,
     * что доступ к данному полю есть только внутри данного класса.
     * Таким образом мы скрываем внутреннюю реализацию класса.
     *
     * Для чего мы это делаем:
     * 1)Пользователи класса видят только важные для них методы,
     * что упрощает понимание и использование кода
     * 2)Мы получаем возможность изменять структуру класса, не затрагивая при этом
     * пользователей класса. Например, если мы захотим переименовать поле elements,
     * мы легко это сможем сделать,  поскольку мы можем быть уверны,
     * что доступ к полю закрыт вне данного класса.
     *
     * Контроль над доступом называют сокрытием реализации.
     * Помещение данных и методов в классы в комбинации с сокрытием реализации называют инкапсуляцией.
     */
    private Object[] elements;

    /**
     * Конструктор без параметров или конструктор по умолчанию.
     * По умолчанию создаем массив размера 5.
     */
    public ArrayList() {
        /**
         *  Ключевое слово this представляет собой ссылку на объект,
         *  для которого был вызван метод или конструктор.
         *  Может использоваться только внутри нестатических методов
         *
         * В данном случае this используется для вызова коструктора с параметром текущего класса
         * см. его определение ниже
         */
        this(5);
    }

    /**
     * Конструктор с параметром
     * @param size начальный размер массива elements
     */
    public ArrayList(int size) {
		/* Вызов родительского конструктора
		 * Можно не писать, конструктор без параметров родительского класса вызовется автоматически.
		 * Есть необходимость использовать явно только конструктор родительского класса с параметрами.
		 * */
        super();
        //создаем массив заданного размера
        elements = new Object[size];
    }

    /**
     * Метод добавления элемента в конец списка
     */
    public void add(Object o) {
        ensureCapacity(size + 1);
        elements[size++] = o;

    }

    /**
     * Метод получения значения элемента по индексу
     */
    public Object get(int i) {
        if (i >= size) {
            return null;
        }
        return elements[i];
    }

    /**
     * Метод удаления элемента по индексу
     */
    public Object remove(int i) {
        if (i >= size) {
            return null;
        }
        Object oldValue = elements[i];
        //сдвигаем элемены на 1 позицию вперед
        for (int j = i; j < size; j++) {
            elements[j] = elements[j + 1];
        }
        //обнуляем последний элемент и уменьшаем размер списка
        elements[--size] = null;
        return oldValue;
    }

    /**
     * Метод проверяет поместится ли в массив elements size элементов
     * При необходимости увеличивает массив elements
     * @param size количество элементов, которое должно входить в массив elements
     *
     * Модификатор доступа private указывает на то, что данный метод доступен только в текущем классе.
     * Это вспомогательный метод, мы не хотим, чтобы пользователям он был виден.
     */
    private void ensureCapacity(int size) {
        if (size <= elements.length) {
            return;
        }
		/* создаем новый массив размера в 2 раза больше,
		 * чем количество элементов, которое мы хотим там разместить
		 */
        Object[] newElements = new Object[2 * size];
        //копируем в него элементы из старого массива
        for (int i = 0; i < elements.length; i++) {
            newElements[i] = elements[i];
        }
        //присваеваем новый массив полю elements
        elements = newElements;
    }

    /**
     * Логики нет, просто пример переопределения метода родительского класса.
     *
     *  Если вы переопределяете какой-то из методов родительского класса, то имейте в виду, что в Java при наследовании запрещается уменьшать уровень доступа,
     *  поэтому при наследовании protected методы и поля в классе потомке должны иметь доступ protected или public,
     *  в public методы и поля родительского класса должны иметь public доступ в классе потомке.
     *
     *  Модификаторы доступа от меньшего к большему:
     *  private - доступ на уровне класса
     *  по умолчанию - доступ в текущем пакете
     *  protected - доступ в текущем пакете и в классах наследниках
     *  public - доступен везде
     */
    public boolean isEmpty() {
        return true;
    }
}
